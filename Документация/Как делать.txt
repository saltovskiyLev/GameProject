0) Подключение библеотек
0.1) Создали проект(wpf)
0.2) В правом меню(Solution Explorer) щёлкнуть правой кнопкой по пункту ссылки(references)
0.3) Нажать добавить ссылку(Add reference)
0.4) Нажать обзор(browse) и найти четыре библеотеки GameProject.


1) подготовка карты
Игра происходит на клеточной карте.

	Как сделать клеточную карту?
Ответ: 
1.1) В Xaml разметке создать Контейнер(StackPanel) с именем
1.2) Далее нужно создать объект типа CellMapInfo с параметрами карт.
1.3) Ещё создаём саму карту...

		...пример...
        static public UniversalMap_Wpf map; // Объект карты. Объявляем на уровне класса. Создаём карту в конструкторе окна(Main Window).
        CellMapInfo mapInfo = new CellMapInfo(клеток по X, Клеток по Y, длина стороны клетки, отступ от границ контейнера);
		...пример...
		
1.4) Добавить объект карты в Children Containder.
			...пример...
            Имя_контейнера.карты_карты.Children.Add(map.Canvas); // Проблема с Children.
			...пример...

	//map = MapCreator.GetUniversalMap(this, mapInfo); Этой стоки и объяснения не было.

	Как нарисовать на клеточной карте изображение?
Ответ:

1.1) Cоздать функцию AddPictures.
1.2) Указать путь к папке с картинками(С помощю функции ImagesFolder)
			...пример...
            map.Library.ImagesFolder = new PathInfo { Path = "..\\..\\images", Type = PathType.Relative }; // Если мы указываем свою папку images, тогда пишем PathType.
			...пример...

2) Считываем и рисуем карту.
2.1) Подключаем пространство имён  пример ->using System.IO;<- пример для работы с файлами.
2.2) Получаем масив строк из файла пример ->File.ReadAllLines(имя файла)<- пример.
2.3) Определяем максимальную длинну строки(кол-во столбцов).
	2.3.1) Создаём две переменные(int) результата, одна хранит номер элемента массива предположительно с максимальной длинной(начальное значение = 0); вторая хранит предположительено максимальную длинну у элемента с номером 0;
	2.3.2) Объявляем цикл for для сравнения всех элементов массива(предположительно самым длинным).
	2.3.3) В форе выполняем проверку: очередной элемент массива оказаля длинее "самого длинного", если ДА, то мы сохраняем в переменных результата номер очередного элемента и его длинну.
	2.3.4) После завершения цикла в переменных результата будет номер и максимальная длинна строки в массиве;
2.4) Создаём двумерный массив символов(char), где x кол-во столбцов, а y кол-во строк.
2.5) С помощю цикла for заполняем двумерный массив символов(char) засчёт перебора массива строк.
	2.5.1) Перебираем исходный массив строк(считанных из файла)
	2.5.2) Каждою строку разбираем на символы и записываем в массив символов который хранит карту.
2.6) Перебираем заполненный двумерный массив символов и с помощю switch рисуем его картинку -> map.DrawInCell("ключ картинки", x, y) <-
2.6.1) Для движущихся объектов необходимо создать GameObject и передать в него стартовые координаты(переменная GameObject создаётся на уровне окна).

3) GameObject
3.1) GameObject содержит поля(переменные):
-статическая переменная игровой карты(тип называется: UniversalMap_Wpf), присвоить значение переменной нужно в конструкторе окна до любых действий с картой(кроме создания). пример -> GameObject.map = map <- пример
-координаты(x,y)
-имя картинки
-словарь параметров
-список предметов в инвенторе
3.2) GameObject содержит методы(функции):
3.2.1) Конструктор GameObject
-принемает параметры(координаты(x и y), имя картинки)
-Конструктор должен сохранить имя картинки, и нарисовать объект в переданных координатах;
3.2.2) Функция перемещения объекта
параметры функции(принемает: координаты)
-Стираем объект по старым координатам
-Сохроняем координаты в переменных класса
-Рисуем объект по новым координатам.
3.3) перед использованием GameObject в основном коде программы нужнно задать значения переменной карты. пример -> GameObject.map = map;

4) Праверка нажатия клавиш
4.1) Игрок это GameObject
4.2) Создаём функцию void CheckKey с параметром Key k.
4.3) Устанавливаем эту функцию в качестве обработчика нажатий map.Keyboard
- map.Keyboard.SetSingleKeyEventHandler() | параметром является название функции ИМЕЕННО НАЗВАНИЕ БЕЗ ПАРАМЕТРОВ!!!
4.4) В самой CheckKey проверяем с помощю switch какая клавиша нажата и выполняем соответствующее ей действие.

5) Движение
В проверке нажатия на клавишу движения
5.1) Проверить является ли клетка проходимой через switch(в отдельной функции).
5.2) Если проходимо, то переместить игрока.
5.3) Проверить какой объект находится в новой клетке и при необходимости выполнить действия с этим объектом(в отдельной функции).

6) Сбор(Collect)
6.1) На урове класса должна быть создан словарь(Dictionary) предиетов с парой ключей(строка и число).
6.2) Создаём функцию с параметрами координат которая проверяет наличие предмета в клетке в которую пришёл игрок -
спомощью switch проверяем есть ли в этой клетке предмет для сбора(это мы делаем спомощью двумерного массива клеточной карты Cells с координатами переданными параметров функции) -
создаём переменную для хранения названия собранного предмета с начальным значением "" -
в case записывается название предмета в переменную созданную на уровне функции, стираем картинку предмета с карты(это внутри case) -
...после switch... если в переменной переданного предмета пустая строка выходим из функции(return) - 
проверяем значение переменной собранного предмета, если этот ключ есть в словаре, то прибавляем единиу к элементу словаря со значением ключа названия предмета. ПРИМЕР Items.Keys.Contains(переменная названия предмета)) ПРИМЕР

 namespace Квест_2022
 MainWindow.cs строка 111
            if(Items.Keys.Contains(ItemName))
            {
                Items[ItemName]++;
            }

	else
	{
		Items.Add(ItemName, 1);
	}
		

7) Отображение собранных предметовm
7.1) Создаём TextBlock внутри StackPanel с картой в котором будут отображатся наши предметы.
7.2) Создаём функцию внутри которой создаём переменную для храниния текста с перечислением собюбранных предметов.
7.3) В функции выполняется цикл foreach где мы создаём переменную для перебора строк которая будет перебирать значения ключей словарей предметов(Items).
7.4) В нашу созданную переменную для хранения текста пребовляем название и количество очередного предмета.
7.5) Эта функция должна вызыватся в функции сбора, после всех операций и присваеваем нашему TextBlock.Text функцию



8) Свитки
8.1) Создаём тестовый файл и называем scrolls*.txt   где * это номер карты начиная с одного
8.2) В файле находится строки в виде 

  -пример-
!|Текст свитка1
@|Текст свитка2
#|Текст свитка3
  -пример-

Где символ первый символ является ключом свитка, второй является разделяющим символом после которого идёт текст свитка.

8.3) Создаём на уровне класса Dictionary с пораметрами(char и string)
8.4) Функция чтения свитков.
//ОТЧИСТИТЬ СЛОВАРЬ С ПОМОЩЬЮ НазваниеСловаря.clear
8.4.1) Параметры функции(номер карты)
8.4.2) Читаем строки из файла с текстом и записываем их в массив строк

string[] s = File.ReadAllLines(@"C:\GameProject - master\GameProject - master\Квест2022\Квест 2022\scrolls" + входной параметр + ".txt");
            
8.4.3) В цикле for перебираем строки прочитанные из файла выше. 

for(int i = 0; i < s.Length; i++)
            {
                string[] str = s[i].Split('|'); // Разбиваем строку из файла на массив из двух строк(ключ, значение).
                Scrolls.Add(str[0][0], str[1]); // Записываем в словарь полученные ключь, значение.
            }

8.5) ДОБАВИТЬ ВСЕ СВИТКИ В ОТРЕСОВКУ КАРТЫ!!!
8.6) При собрании свитка в MessageBox.Show(Имя переменной словаря[символ собранногосвитка])

9) АНИМАЦИЯ
9.1) Создаём функцию для добавления сета картинок и создания анимации
9.1.1) Начальныйе параметры функции это корень картинки(часть слова повторяющаяся каждый раз) и количество картинок
9.1.2) Создаём объект анимации(AnimathionDefenition) и строковую переменную для хранения названия файла.
9.1.3) Делаем фор где мы формеруем номер картинки и именя файла.
9.1.4) В переменную для хранения названия картинки(полного) добавляем основу слова(входной параметр) и номер картинки(счётчик).
9.1.5) Добавляем картинку в код(map.Library.AddPicture) в параметре названия пишем нашу основу слова + счётчик, а вторым параметром переменную в которую передали полное название картинки.
9.1.6) В наш объект анимации добавляем(название объекта.AddFrame) кадр(картинку) с параметрами время отображения на экране и названия картинки.
9.1.7) После цикла for добавляем объект анимации в карту с помощью map.Library.AddAnimation(основа слова, объект анимации).

10) Создание плавного текст блока
10.1) Создаём переменную типа Action;
10.2) Создаём функцию типа void без параметров которая будет менять яркость нашему TextBlock.
10.2.1) В функции делаем проверку что прозрачность нашего TextBlock больше нуля.
10.2.2) Если да то уменьшаем(-=) прозрочность где-то на 0.01 или по как нужно.
10.3) Добавляем в Action только что созданную функцию.
10.4) Создаём функцию которая будет вызываться таймером с параметром object pare = null;

 !!! -> if(Application.Current != null) Application.Current.Dispatcher.Invoke(ShowText); <- !!!
 
10.4.1) Эта строка проверяет что current не равно нулю, а затем Через функцию Invoke вызываем делегат(action)
10.5) Объевляем переменную типа Timer.
10.5.1) В конструкторе окна создаём TimerCallBack и в качестве параметра объекта пишем нашу функцию которя вызывается таймером.
10.5.2) Создаём Timer через четыре параметра(первым из которых является созданная ранее переменная(CallBack), вторым null, третим через сколько времени запуститься таймер(в нашем случае 0), а четвёртым - переодичность вызова таймера;
Окна WPF----------------------------------------------------------------------------Окна WPF
0) Добавляем окно в проект;
0.1) Кликаем на название проекта в Solushion Explorer и нахадим Add->NewItem
0.2) Находим WindowWpf и называем класс

1) Разметка окна;
1.1) Внутри окна должен находится контейнер компоновки(StackPanel, WrapPanel, DockPanel, Grid, -)
1.2) Неопходимо сделать рисунок с разметкой окна, с вложеными контейнерами компоновки
1.3) 


Контейнеры компоновки:
StackPanel(Orientation)
WrapPanel(Orientation)
Grid -пример->

<Grid>
	<Grid.ColumnDefinitions> // ColumnDefinitions- это описание столбцов, каждый вложеный ColumnDefinition - это сталобец таблицы.
		<ColumnDefinition Width="*"> </ColumnDefinition>
		<ColumnDefinition Width="100"> </ColumnDefinition>
	</Grid.ColumnDefinitions>

	<Grid.RowDefinitions> // RowDefinitions - это описание строк, каждый вложеный RowDefinition - это строки таблицы.
		<RowDefinition Height="2*"> </RowDefinition>
		<RowDefinition Height="3*"> </RowDefinition>
		
	</Grid.RowDefinitions>
	<TextBlock Grid.Column="0" Grid.Row="1" x:Name="tbGritings"> // Для каждого элемента внутри grid мы должны обозначить строку и столбец.
	</TextBlock>
	<Image Grid.Column="1" Grid.Row="1" Name="imgAvatar"> </Image>
	<WrapPanel Name="ProductList" Grid.Row="0" Grid.Column="0"> </WrapPanel>
</Grid>

<-пример- Grid

2) Класс для отображения товаров или предметов игрока.(ShopItemUI)
2.1) Этот класс унаследованный от StackPanel
2.2) В этом классе есть два StackPanel с вертикальной ориентацией
2.3) Создаём конструктор с двумя входными параметрами(строка - имя предмета, число - стоимость предмета или кол-во предметов)
2.4) Передаём входные параметры в соответствующие TextBlock которые создали на уровне класса
2.5) В конструкторе с помощью this передаём StackPanel такие параметры как: Вертикальная ориентация, к потомкам панели передаём два TextBlock которые заполняли ранее и отступ Margin.
2.6) Созданый предмет добавляем в Children контейнера 


3) Создаём два словаря(Dictionary) на уровне класса окна магазина.
3.1) В коде главного окна создаём экземпляр класса магазина.
3.2) В переменные словарей записываем исходные данные из кода главного окна.
3.3) В классе магазина должна быть функция Init.
3.4) Функция Init создаёт на основе словарей создаёт экземпляры ShopItemUI и добавляет их к панелям прелметов игрока и предметов на продажу.
3.4.1) Для перебора двух словарей используем циклы foreach пример: foreach(string key in ShopItems.Keys); вторая строка: ShopItemUI item = new ShopItemUI(key, ShopItems[key]);
3.5) В TextBlock со значением денег игрока. Количество денег игрока берём из словаря денег игрока по ключу "coin"(например);
3.6) Отоброзить окно можно с помощю ShowDialog;
JSON--------------------------------------------------------------------------------JSON
0)Подключение Newtonsoft.Json;
0.1) Щёлкнуть правой кнопкой в имени проекта(Solushion Explorer), выбираем - Manage NuGet packages -
0.2) В открытом окне переходим на вкладку browse, в строке поиска выбираем и инсталируем - Newtonsoft.Json -
0.3) Подключаем нужный namspase(Newtonsoft.Json).

1) Создание класса сериализуемого в json.
1.1) Все сериалезуемые поля должны быть объевлены с { get; set; }
1.2) К сериалезуемым полям необходимо установить атрибут JsonProperty.

ПРИМЕР

	[JsonProperty("mapName")] // название в ковычках, это то как будет называется переменная в json строке.
	public string MapName { get; set; }
		
ПРИМЕР

2) Сериализация и десериализация
2.1) Чтобы превратить объект в json строку, нужно вызвать функцию  - JsonConvert.SerializeObject(объект);

- ТИП ОБЪЕКТА НЕ ВАЖЕН, ВАЖНО НАЛИЧИЕ АТРИБУТОВ!!!

2.2) Эта функция string s = JsonConvert.SerializeObject(объект); возвращает строку, которую надо куда-то записать
2.3) Чтобы восстановить объект из строки нужно -

 Класс объект = JsonConvert.DeserializeObject<Класс>(json строка);
 
 Здесь обезятельно нужнро указывать тип данных в который нужно превратить строку "Класс";

-------------------------------------------------------------------------------- <НАПОМИНАНИЯ>
1) Переменный которые должны быть доступны всем функциям класса(окна) объявляются на уровне класса!
2) Переменная в экземпляре класса становится доступной для чтения и записи с помощью ключевого слова public-
-если нужно чтобы все имели доступ только на чтение, то пример -> public int X { get; private set; } !
3) Конструктор класса всегда public и не имеет типа!