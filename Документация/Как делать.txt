0) Подключение библеотек
0.1) Создали проект(wpf)
0.2) В правом меню(Solution Explorer) щёлкнуть правой кнопкой по пункту ссылки(references)
0.3) Нажать добавить ссылку(Add reference)
0.4) Нажать обзор(browse) и найти четыре библеотеки GameProject.


1) подготовка карты
Игра происходит на клеточной карте.

	Как сделать клеточную карту?
Ответ: 
1.1) В Xaml разметке создать Контейнер(StackPanel) с именем
1.2) Далее нужно создать объект типа CellMapInfo с параметрами карт.
1.3) Ещё создаём саму карту...

		...пример...
        static public UniversalMap_Wpf map; // Объект карты. Объявляем на уровне класса. Создаём карту в конструкторе окна(Main Window).
        CellMapInfo mapInfo = new CellMapInfo(клеток по X, Клеток по Y, длина стороны клетки, отступ от границ контейнера);
		...пример...
		
1.4) Добавить объект карты в Children Containder.
			...пример...
            Имя_контейнера.карты_карты.Children.Add(map.Canvas); // Проблема с Children.
			...пример...

	//map = MapCreator.GetUniversalMap(this, mapInfo); Этой стоки и объяснения не было.

	Как нарисовать на клеточной карте изображение?
Ответ:

1.1) Cоздать функцию AddPictures.
1.2) Указать путь к папке с картинками(С помощю функции ImagesFolder)
			...пример...
            map.Library.ImagesFolder = new PathInfo { Path = "..\\..\\images", Type = PathType.Relative }; // Если мы указываем свою папку images, тогда пишем PathType.
			...пример...

2) Считываем и рисуем карту.
2.1) Подключаем пространство имён  пример ->using System.IO;<- пример для работы с файлами.
2.2) Получаем масив строк из файла пример ->File.ReadAllLines(имя файла)<- пример.
2.3) Определяем максимальную длинну строки(кол-во столбцов).
	2.3.1) Создаём две переменные(int) результата, одна хранит номер элемента массива предположительно с максимальной длинной(начальное значение = 0); вторая хранит предположительено максимальную длинну у элемента с номером 0;
	2.3.2) Объявляем цикл for для сравнения всех элементов массива(предположительно самым длинным).
	2.3.3) В форе выполняем проверку: очередной элемент массива оказаля длинее "самого длинного", если ДА, то мы сохраняем в переменных результата номер очередного элемента и его длинну.
	2.3.4) После завершения цикла в переменных результата будет номер и максимальная длинна строки в массиве;
2.4) Создаём двумерный массив символов(char), где x кол-во столбцов, а y кол-во строк.
2.5) С помощю цикла for заполняем двумерный массив символов(char) засчёт перебора массива строк.
	2.5.1) Перебираем исходный массив строк(считанных из файла)
	2.5.2) Каждою строку разбираем на символы и записываем в массив символов который хранит карту.
2.6) Перебираем заполненный двумерный массив символов и с помощю switch рисуем его картинку -> map.DrawInCell("ключ картинки", x, y) <-
2.6.1) Для движущихся объектов необходимо создать GameObject и передать в него стартовые координаты(переменная GameObject создаётся на уровне окна).

3) GameObject
3.1) GameObject содержит поля(переменные):
-статическая переменная игровой карты(тип называется: UniversalMap_Wpf), присвоить значение переменной нужно в конструкторе окна до любых действий с картой(кроме создания). пример -> GameObject.map = map <- пример
-координаты(x,y)
-имя картинки
-словарь параметров
-список предметов в инвенторе
3.2) GameObject содержит методы(функции):
3.2.1) Конструктор GameObject
-принемает параметры(координаты(x и y), имя картинки)
-Конструктор должен сохранить имя картинки, и нарисовать объект в переданных координатах;
3.2.2) Функция перемещения объекта
параметры функции(принемает: координаты)
-Стираем объект по старым координатам
-Сохроняем координаты в переменных класса
-Рисуем объект по новым координатам.
3.3) перед использованием GameObject в основном коде программы нужнно задать значения переменной карты. пример -> GameObject.map = map;

4) Праверка нажатия клавиш
4.1) Игрок это GameObject
4.2) Создаём функцию void CheckKey с параметром Key k.
4.3) Устанавливаем эту функцию в качестве обработчика нажатий map.Keyboard
- map.Keyboard.SetSingleKeyEventHandler() | параметром является название функции ИМЕЕННО НАЗВАНИЕ БЕЗ ПАРАМЕТРОВ!!!
4.4) В самой CheckKey проверяем с помощю switch какая клавиша нажата и выполняем соответствующее ей действие.

5) Движение
В проверке нажатия на клавишу движения
5.1) Проверить является ли клетка проходимой через switch(в отдельной функции).
5.2) Если проходимо, то переместить игрока.
5.3) Проверить какой объект находится в новой клетке и при необходимости выполнить действия с этим объектом(в отдельной функции).

6) Сбор(Collect)
6.1) На урове класса должна быть создан словарь(Dictionary) предиетов с парой ключей(строка и число).
6.2) Создаём функцию с параметрами координат которая проверяет наличие предмета в клетке в которую пришёл игрок -
спомощью switch проверяем есть ли в этой клетке предмет для сбора(это мы делаем спомощью двумерного массива клеточной карты Cells с координатами переданными параметров функции) -
создаём переменную для хранения названия собранного предмета с начальным значением "" -
в case записывается название предмета в переменную созданную на уровне функции, стираем картинку предмета с карты(это внутри case) -
...после switch... если в переменной переданного предмета пустая строка выходим из функции(return) - 
проверяем значение переменной собранного предмета, если этот ключ есть в словаре, то прибавляем единиу к элементу словаря со значением ключа названия предмета. ПРИМЕР Items.Keys.Contains(переменная названия предмета)) ПРИМЕР

 namespace Квест_2022
 MainWindow.cs строка 111
            if(Items.Keys.Contains(ItemName))
            {
                Items[ItemName]++;
            }

	else
	{
		Items.Add(ItemName, 1);
	}
		

7) Отображение собранных предметовm
7.1) Создаём TextBlock внутри StackPanel с картой в котором будут отображатся наши предметы.
7.2) Создаём функцию внутри которой создаём переменную для храниния текста с перечислением собюбранных предметов.
7.3) В функции выполняется цикл foreach где мы создаём переменную для перебора строк которая будет перебирать значения ключей словарей предметов(Items).
7.4) В нашу созданную переменную для хранения текста пребовляем название и количество очередного предмета.
7.5) Эта функция должна вызыватся в функции сбора, после всех операций и присваеваем нашему TextBlock.Text функцию



8) Свитки
8.1) Создаём тестовый файл и называем scrolls*.txt   где * это номер карты начиная с одного
8.2) В файле находится строки в виде 

  -пример-
!|Текст свитка1
@|Текст свитка2
#|Текст свитка3
  -пример-

Где символ первый символ является ключом свитка, второй является разделяющим символом после которого идёт текст свитка.

8.3) Создаём на уровне класса Dictionary с пораметрами(char и string)
8.4) Функция чтения свитков.
//ОТЧИСТИТЬ СЛОВАРЬ С ПОМОЩЬЮ НазваниеСловаря.clear
8.4.1) Параметры функции(номер карты)
8.4.2) Читаем строки из файла с текстом и записываем их в массив строк

string[] s = File.ReadAllLines(@"C:\GameProject - master\GameProject - master\Квест2022\Квест 2022\scrolls" + входной параметр + ".txt");
            
8.4.3) В цикле for перебираем строки прочитанные из файла выше. 

for(int i = 0; i < s.Length; i++)
            {
                string[] str = s[i].Split('|'); // Разбиваем строку из файла на массив из двух строк(ключ, значение).
                Scrolls.Add(str[0][0], str[1]); // Записываем в словарь полученные ключь, значение.
            }

8.5) ДОБАВИТЬ ВСЕ СВИТКИ В ОТРЕСОВКУ КАРТЫ!!!
8.6) При собрании свитка в MessageBox.Show(Имя переменной словаря[символ собранногосвитка])

JSON--------------------------------------------------------------------------------JSON
0)Подключение Newtonsoft.Json;
0.1) Щёлкнуть правой кнопкой в имени проекта(Solushion Explorer), выбираем - Manage NuGet packages -
0.2) В открытом окне переходим на вкладку browse, в строке поиска выбираем и инсталируем - Newtonsoft.Json -
0.3) Подключаем нужный namspase(Newtonsoft.Json).

1) Создание класса сериализуемого в json.
1.1) Все сериалезуемые поля должны быть объевлены с { get; set; }
1.2) К сериалезуемым полям необходимо установить атрибут JsonProperty.

ПРИМЕР

	[JsonProperty("mapName")] // название в ковычках, это то как будет называется переменная в json строке.
	public string MapName { get; set; }
		
ПРИМЕР

2) Сериализация и десериализация
2.1) Чтобы превратить объект в json строку, нужно вызвать функцию  - JsonConvert.SerializeObject(объект);

- ТИП ОБЪЕКТА НЕ ВАЖЕН, ВАЖНО НАЛИЧИЕ АТРИБУТОВ!!!

2.2) Эта функция string s = JsonConvert.SerializeObject(объект); возвращает строку, которую надо куда-то записать
2.3) Чтобы восстановить объект из строки нужно -

 Класс объект = JsonConvert.DeserializeObject<Класс>(json строка);
 
 Здесь обезятельно нужнро указывать тип данных в который нужно превратить строку "Класс";

-------------------------------------------------------------------------------- <НАПОМИНАНИЯ>
1) Переменный которые должны быть доступны всем функциям класса(окна) объявляются на уровне класса!
2) Переменная в экземпляре класса становится доступной для чтения и записи с помощью ключевого слова public-
-если нужно чтобы все имели доступ только на чтение, то пример -> public int X { get; private set; } !
3) Конструктор класса всегда public и не имеет типа!