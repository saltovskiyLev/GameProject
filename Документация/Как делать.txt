0) Подключение библеотек
0.1) Создали проект(wpf)
0.2) В правом меню(Solution Explorer) щёлкнуть правой кнопкой по пункту ссылки(references)
0.3) Нажать добавить ссылку(Add reference)
0.4) Нажать обзор(browse) и найти четыре библеотеки GameProject.


1) подготовка карты
Игра происходит на клеточной карте.

	Как сделать клеточную карту?
Ответ: 
1.1) В Xaml разметке создать Контейнер(StackPanel) с именем
1.2) Далее нужно создать объект типа CellMapInfo с параметрами карт.
1.3) Ещё создаём саму карту...

		...пример...
        static public UniversalMap_Wpf map; // Объект карты. Объявляем на уровне класса. Создаём карту в конструкторе окна(Main Window).
        CellMapInfo mapInfo = new CellMapInfo(клеток по X, Клеток по Y, длина стороны клетки, отступ от границ контейнера);
		...пример...
		
1.4) Добавить объект карты в Children Containder.
			...пример...
            Имя_контейнера.карты_карты.Children.Add(map.Canvas); // Проблема с Children.
			...пример...

	//map = MapCreator.GetUniversalMap(this, mapInfo); Этой стоки и объяснения не было.

	Как нарисовать на клеточной карте изображение?
Ответ:

1.1) Cоздать функцию AddPictures.
1.2) Указать путь к папке с картинками(С помощю функции ImagesFolder)
			...пример...
            map.Library.ImagesFolder = new PathInfo { Path = "..\\..\\images", Type = PathType.Relative }; // Если мы указываем свою папку images, тогда пишем PathType.
			...пример...

2) Считываем и рисуем карту.
2.1) Подключаем пространство имён  пример ->using System.IO;<- пример для работы с файлами.
2.2) Получаем масив строк из файла пример ->File.ReadAllLines(имя файла)<- пример.
2.3) Определяем максимальную длинну строки(кол-во столбцов).
	2.3.1) Создаём две переменные(int) результата, одна хранит номер элемента массива предположительно с максимальной длинной(начальное значение = 0); вторая хранит предположительено максимальную длинну у элемента с номером 0;
	2.3.2) Объявляем цикл for для сравнения всех элементов массива(предположительно самым длинным).
	2.3.3) В форе выполняем проверку: очередной элемент массива оказаля длинее "самого длинного", если ДА, то мы сохраняем в переменных результата номер очередного элемента и его длинну.
	2.3.4) После завершения цикла в переменных результата будет номер и максимальная длинна строки в массиве;
2.4) Создаём двумерный массив символов(char), где x кол-во столбцов, а y кол-во строк.
2.5) С помощю цикла for заполняем двумерный массив символов(char) засчёт перебора массива строк.
2.6) Перебираем заполненный двумерный массив символов и с помощю switch рисуем его картинку -> map.DrawInCell("ключ картинки", x, y) <-

3) GameObject
3.1) GameObject содержит поля(переменные):
-статическая переменная игровой карты(тип называется: UniversalMap_Wpf), присвоить значение переменной нужно в конструкторе окна до любых действий с картой(кроме создания). пример -> GameObject.map = map <- пример
-координаты(x,y)
-имя картинки
-словарь параметров
-список предметов в инвенторе
3.2) GameObject содержит методы(функции):
-Отоброзить объект в клетке с переданными координатами
3.3) Функция перемещения объекта
-Стираем объект по старым координатам
-Сохроняем координаты в переменных класса
-Рисуем объект по новым координатам.
3.4) перед использованием GameObject в основном коде программы нужнно задать значения переменной карты. пример -> GameObject.map = map;

4) Праверка нажатия клавиш
4.1) Игрок это GameObject
4.2) Создаём функцию void CheckKey с параметром Key k.
4.3) Устанавливаем эту функцию в качестве обработчика нажатий map.Keyboard
4.4) В самой CheckKey проверяем с помощю switch какая клавиша нажата и выполняем соответствующее ей действие.

5) Движение
В проверке нажатия на клавишу движения
5.1) Проверить является ли клетка проходимой через switch(в отдельной функции).
5.2) Если проходимо, то переместить игрока.
5.3) Проверить какой объект находится в новой клетке и при необходимости выполнить действия с этим объектом(в отдельной функции).

-------------------------------------------------------------------------------- <НАПОМИНАНИЯ>
1) Переменный которые должны быть доступны всем функциям класса(окна) объявляются на уровне класса!
2) Переменная в экземпляре класса становится доступной для чтения и записи с помощью ключевого слова public-
-если нужно чтобы все имели доступ только на чтение, то пример -> public int X { get; private set; } !
3) Конструктор класса всегда public и не имеет типа!